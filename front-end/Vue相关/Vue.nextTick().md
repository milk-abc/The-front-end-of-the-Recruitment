JS运行机制
JS执行是单线程的，它是基于事件循环的。
1.所有同步任务都在主线程上执行，形成一个执行栈。
2.主线程之外，会存在一个任务队列，只要异步任务有了结果，就在任务队列中放置一个事件。
3.当执行栈中的所有同步任务执行完后，就会读取任务队列。那些对应的异步任务，会结束等待状态，进入执行栈。
4.主线程不断重复第三步
主线程的执行过程就是一个tick，而所有的异步结果都是通过任务队列来调度。Event Loop分为宏任务和微任务，无论是执行宏任务还是微任务，完成后都会进入到下一个tick，并在两个tick之间进行UI渲染。
for(let i=0; i<100; i++){
    dom.style.left = i + 'px';
}
以上代码浏览器会进行100次DOM更新吗？显然不是的，这样太耗性能了。事实上，这100次for循环同属于一个task，浏览器只在该task执行完后进行一次DOM更新。
Vue的数据响应过程包括：数据更改->通知watcher->更新DOM
修改数据是同步任务，同一事件循环的所有的同步任务都在主线程上执行，形成一个执行栈。并开启一个异步队列，如果同一个watcher被多次触发，只会被推入到队列中一次。

Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。
MutationObserver：是一个用于监视DOM变动的接口，它可以监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等。

Vue的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。
当响应式数据更新后，会调用dep.notify，通知dep中收集的watcher去执行update方法，watcher.update将watcher自己放入一个queue数组。然后通过nexttick方法将一个刷新watcher队列的方法(flushSchedulerQueue)放入一个全局的callbacks数组中。
flushCallbacks函数负责执行callbacks数组中所有flushScheduleQueue函数。
flushSchedulerQueue函数负责刷新watcher队列，即执行queue数组中每一个watcher的run方法，从而进入更新阶段，比如执行组件update更新函数或者执行用户watch的回调函数渲染新数据到dom上。
如果此时浏览器的异步任务队列中没有一个叫flushCallbacks的函数，则执行timerFunc函数，将flushCallbacks函数放入异步任务队列。如果异步任务队列中已经存在flushCallbacks函数，等待其执行完成以后再放入下一个flushcallbacks函数。
flushcallbacks将pending设置为false，表示下一个flushcallbacks函数可以进入浏览器的异步任务队列，清空callbacks数组，执行callbacks数组中的所有函数。如flushShedulerQueue,自定义nextTick回调函数
怎么去重

当响应式数据更新后，会调用dep.notify，通知dep中收集的watcher去执行update方法中的queuewatcher，此方法通过判断has对象中是否已经有了watcher.id，当没有watcher.id就将watcher放入queue，并设置has[id]=true。再定义一个用于刷新watcher队列的方法flushSchedulerQueue。
通过nextTick方法将一个刷新watcher队列的方法flushSchedulerQueue放入callbacks数组中。
会定义一个flushcallbacks方法，它会将pending设为true,并执行callbacks中的flushSchedulerQueue。
将timeFunc定义为一个将flushcallbacks方法放入异步队列中的函数，可以设置为promise,mutationobserver,setImmediate,setTimeout。判断pending是否为false，是的话执行timeFunc，也就是异步执行flushcallbacks，flushcallbacks将pending设置为true，清空callbacks数组，并执行callbacks数组中的所有函数，flushSchedulerqueue函数和自定义nextTick回调函数。flushSchedulerQueue函数负责刷新watcher队列queue数组，执行queue数组中每一个watcher的run方法，从而进入dom更新阶段，比如执行组件的updated更新函数或者执行用户watch的回调函数渲染新数据到dom上。
callbacks数组包含flushSchedulerqueue
flushSchedulerqueue包含watcher queue
timefunc包含flushcallbacks
flushcallbacks执行callbacks数组中的所有flushSchedulerqueue
当响应式数据更新，调用dep.notify()，执行dep数组中的watcher.update()，调用queueWatcher函数，通过判断has对象中是否有watcher.id，如果没有则加入queue数组，并设置has[watcher.id]=true，达到去重的效果。定义flushShedulerQueue函数用于刷新queue数组，按watcherid顺序执行queue数组中的每一个watcher的run方法，也就是watcher的回调函数用于渲染新数据到dom上。通过调用nextTick函数将flushSchedulerQueue放入callbacks数组中，当pending为false时，将其设为true，执行timeFunc函数，timeFunc函数用于将flushcallbacks函数放入异步队列，而flushcallbacks函数用于执行callbacks数组中的每个flushSchedulerQueue函数或者自定义的nextTick函数，并将pending设为false。
